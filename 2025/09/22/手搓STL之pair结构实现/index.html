<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"><meta name="description" content="手搓STL之pair结构实现 - This is Pequod! Arriving shortly at LZ!"><meta name="theme-color" content="#6ba8a9"><title>手搓STL之pair结构实现 - This is Pequod! Arriving shortly at LZ!</title><style>@font-face {
  font-family: 'Abril Fatface';
  font-style: normal;
  font-weight: 400;
  src: local('Abril Fatface'), local('AbrilFatface-Regular'), url(data:font/woff2;base64,d09GMgABAAAAAB6MAA4AAAAAWmgAAB43AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGi4bl2wcfgZgAHwRCAr+OON7C4JaAAE2AiQDhTAEIAWEWgeLXRvXShVsnMqGjcMAxL/ZoigfnMnF/5+TGzIE+xGnVSsoEkTprOLCatNCL3NWSrwGiVOeC1Ma4cRt9lKgeMLz6SDPn09f5BtlurhiH5hIRzKSsRXMg/2K5qMneJOanClsEllsWP7NwOgqOFj6FH46vhRKUfOL5PSG6O7ZpIb/7ghNTtFKFL8f6Oz9HyB2gEJFGABURA7JRcURynBBVVVVEfjaVjZveNrmvyMVlLgDjAIbq0BRoixmAoc9xagA10Z/t/6hiw51a9Sf5Tr9f+7nX9R9G6UXWCTYMCLEPk9sZ7QJDSSDqqja7xmbofKolVLIeIlEfCKG+J+43uQWboIdYg0osAFwdFtjr5hfMLliVkqHntfzZUk/yOLTCchsysWeVcP5D/2eUnVVDAqlatMITV/otwweT6qRETrBhufZe/w9A0KwLhbLhqekMPw/qOf776uRyqkxyGJz6D2a+mJFZw6JbSj+RXvpp4AlwaA2M4Pyk5OLXTPPnBc+LoXWqgUpPkHy2Uo2sV3v1vv2IDOPXThRzoyIaxUsYlKl49qjjaog0/8yPr1qrfWzbPZC8iVCyr2WaMjLNRWUVF59Wf++grX5gndvjZfkM8m+6LsDLPlb69UlrcgmptDFWDK0IcWKXDEUTU9N2VOim4hET3fOx9aKBJfKXmXqsOuRk57yyGuqMIgiisiWHucv13Ec8//t/Ytzh5bQpP7kAhhufJwLHgQLgpCDKChgKK0HmbATBAIM5SoIZvZ9FyiH99ZXAgocwE+TWQ4drK0EZgB2P+BgAB0L6TUE4sy5/eHKI001IWEpCcknkL/8EAvOEiWpVa9Bo6XWmrDZVhAhKgxhq6tpKyAwHKDn6CXnvAXBSRQ2CMVocSzAGrawhyPYcIYr3OEJL/jADwEIQgjCEActdEA5cOEjRIwUEAUqNOgwYFr6wpGF2tCBLhixpHCZUCsM1vNHHwYwgjGMYw2bFNkWwza2o5FLbvbRaeBs5qrfrid2E7jPHlP2FHjOXkIKAgAAAAAAAAAAAAAAAAAAAAAAAEASSSSRRBJJ9GEWAAAAAAD0oQ99hbNRu9RbGFbYANgvfaSdobjhjife8Ynv8Z7pzs6tzE//CmwAx3qR6+JDdIx70gF2Wx0w9aERucpEqSHczG3IYNUYUXV3gqXVnpWl1FukCSlYkSQO1ateJXEiq2WNaWyW8TSOBdxzOqygMQnapuIQicSQyAQIkyrx+JN5fKRs1qbjA0jTqNheYQ0s2j9VJf6zKo8baai3PDlPejAKERVuDwuDBMTBHF0MxQIq06VOEqWxoo54q97O2ndFO6abDMiN2As0/CytLuRihyqSNGLSxvvolu27IZa08Y5qm6hsSOvQjyXdPdfSUrZaZPKC/pWotKq9fNXnHik3bTaRZr2yybCVHBSuBFhkJfgQs3HqEWGFl7uCDOkTWTZlZviMNdg49F5HsjtyAOmiSdKWyOWRv1KzJAxjMxflsmOwxEJ5fHwlhXL+6XfY3HHmVQFHRlmB6hypqpyXZuNJ0McToMTKzZSEpfQ6ZU07zorLXi034lrEzzLq1oy6f72YcG5+o29Zq5Bk78GvLaFKqWZdtuysCCS6Ldc97Sf5Ka7npEoXmibZXtxbBeegNE9/+knYSn52a5cqiSvuK8LsFHMIDmAeF1Ru9GgKFEhUpEiSEgOSDRvV5CvrtZqwgxGEYTU6MKkLgYdhgO3u2NTFQUbgWW8QYxgRc8cTsLCYsVrQnLW87ySxgQWBqXXJ7Ba0YD9qSw4rp2CjclyQxkkes2NgAS1F0oepSBLSRJHKQBBrsskodSHmI4CRGzykLoRWNLpMBlIjBFbJiZjvS5SaCQQsVqyUwxLR64IY5FFjWawcxxIeaUEzcBLg3EDcK5I+VkZJQpooUvJf/HUjaWXRO6NWrlax0datXsRm/R+AATUzA3X4mL4cUIZ2BkCQh10QEDCYPXUUOKutsdY6EJxKVWrVwWQ6Hnigvq4i4G4zSf4Q5P0/LFonuTT2AdDTcboNG9iziQPiSnrnLz/wQOIyG7gHkN9rETCbgAYaNt40CCI4xY/PRDRYhAQkOV0Zyf968WZem3mGsLUT0PKoy8irrIdenHnap5uR4dwfgY7z+eXPyezD3wQZ1xFQ0yjqm/IFyxYgwwEY9x0w+R2Q20COMzXMBBgTGmQki4VtCiH1akB6Zz+bCOqBBYVM1WwwdxwuxmwIRK0ZfaN2SlYrJlSoVBGJilhm3Tut4Th4atM2pp4Y2WD9A9n0DO5D/eATknLhUQsNzkU+UHJ8iPGh1McYaq5RU40ooZxMsoXUZm3VNPTmNTRwQrSlSeuExEqUac12EjvKooiyomD55DKXi8KsimQpt9jiJqEUL8biQTku5OqRlspKt9w0Zcptv7NczErJSpI0JI1YoRo42INZsHAwDn3SmE3pUhOqqC7VXLXU/1XADBnxpJM6BEiVPqrwINUHiV/TTSktWUqZ7HNwRzTdrKdAhXsmIV4wnmzxjEf8PGmrimdtm6ATiF528nTE+S4KIPpmX6Kd8Uyi1vFP3evw7+HeA4tdZoX+mn19hiW9p3oSCOo3r3f7vPsSUKRjAB9vNOSnQxzte2aSIUHnbvc225VjqIxl3+Cl/FGPHXIuO58IsOceVk6H+Cqy6X+1Oc5SY8ceBXL9fOE87z41mBvuLVhOX2v8vqnHmX1PZI4Qq8e8F0L6Bq7yiWkYk4YEBGLlkH+2r/Vtie6NBPL7jgDt6azA1viYmnuBh+yaGH6EPmc8cuDCnJjxp8r1tU0+76DogBhugyS4R8S54b5rC2gjKAxbl5IMwxZcsmiIH9q2ls7n7/B6GuCV15SKh4+kfYS9YFzy38kXZgSFrexdtlhv9KUnTh8j1RNprT5T30XarpY3b/Q2d9K/4j4r3rV6dJ1pFw1iCK2k5VGc7yWLaAUoh0icLnfiC7/llN725gy7eR/wA+OIOzhz+PJn/Yl3PQHCxqxuucQcO9fx4fcozDkLam/Uk5tcMvDgwa53De4/njyUIxODQRcdeeEK4xiD/cK75DjQVFjbK+n1g3/8sf29u+c99XnRQZba9O112h4iQL0QFNefiZcQWtuxnopsRofb7F2S+rY5qABRqgR1qHvcL5EYdmdfASb1v+beYFwKJJAZhtojLMadJkIMIywSgPS2FCPoK+eymsJ4RiWx3d2wRBES6qR7ZCOa3SNpg8JpqfWyIEZYerzc9rZCKs62DXBR20RnTXC/SygrI+baSlfX+j/xs+MpvIom1MTE5tQ2zJXf82ltuxNVMOYBy0aPeUk7ADT+y9sBkf8MA9YvCFqfrxBeuW+MrUUsnNnvQLv/F5Cefmuxck2ct4Ohb1HVyJfkSkVlnaLIqZAobW6ycxK7X5m5ZpCEOQwlwACIfsVCBHCxttL55xCyCqwkW/KfD6qnpoHogGx48JLrO1YzW3vY9593rasIjworDYYJ3nh4rE3F8svVELL3gyCqS5lLMpiCb1mUlkxR19aC7nQOd/WOLxwV9ztXiPfAi1ZTpJO+k78Zvzb7O3zDDa0fAZ0T0WwaavZLkXo2DDmkcv8ANW9YfGhbkjaOyz7LnEaxZLWY4WLbNd85S/NDEDNSJpYWTBkc2mJUUSYfjyjBKmCfKSpmm2wrbOZ23fRmTStxS/xT0VSkxz9Vvxtqo8YsZ8KqbFEsKYecJhdcVf+dbsKRSi1K7nW0gvJIrBzGnMcrpKuBhg0laVxOjvnJXEoESqKavT3mp5sHRcy6Wm7wSPB0k8HkosY9G6y/uEPZUHB7sld1Y49qq0sMt+p3IGxLz6Fdu+y/AThrs5/3bfP73JL5/tluUytkCfgsnl8GoCsb5W2tLV37mfZUF5HuygjiPnFPG0xqMNsHDDf27nVxM93umWt3W9IxI4G2u6Sgx1G4rUNzBr4uxeyOKqu0e+KZ541zc3Ned6FO76TZbW64x2SYnT08dfy0zW5wsRVOWZO05CKRXTxHhWnbU/65EQNAhOZ+3zTuJPc6eBrW9u41sjaRehgs2ZG5njEGtZPh/5yzlmrE5MDJ3Jltlak3BT6SnfOq0tAmkNdjUpNQ9DgOQgGMxCGqSyRwYNEnm565OVlmI6MhVWna2FWZ0d3FSSoxvbb0RshYOgElIesiojQEf816ZjMJUjDe1Df3Byxdf+uzudilmIWPw9JAuVg/ejkGcu9Z45meU7N3jfd67xhus9t7sc3ZT2UayDsvkboY7tRhnidePKY+Q0s6BjOF7KJwSi+6GrqlHFHOhZbJbT6WnNAEivsco8x+aBvTAnQMIyygDGUAsYcqwYP9iaZblrbuVeJqFnGcoqxnH+gDPzp3UL8ZPe8znWOrydYknamVD10sMGwm9150ySCxEYhwLr3euKXNvF2AjclCpdPX3aY1OnLnk1Bbg8PzHK7DjYqi0zmHIpcklqTLzhrKyDoyFlUzcpwNRd3Us6OtR6BUu6NzesgYlLm/d15r4OTsIfX47GKbQAhWg+4JWIuesE3aUTdLXjbbZAx6RtCQDrZHtnGE4zMjdkglOxy7Xoqj3bEj4xiL1uSYZe5kDc2VcbG999tPCZSZFlX7FfiWs3lekXoNQ3sCMu70YKR1zLl0+6uZlvbmBCrxKSgC1mvGdq3ZwNgANpC0xu/W7Rnfw4LmnSZNPXuMe3tn3daR5Znst873Hkf/t9N946u7wjNbllVOBVr8C557h0U5DLEjfIGTZFMvsHXXprbdaUpPKp8JcXDGF/6OtcMl0mZ67OXgoLGW6OoQ1Z7dTt/5ZhGFGTTAuefjllMVovfWNCoSR+iwxi0so76t/VmfsTMtS158K/EdF5Zw9LQAMGhuWPpoqKP6L7MeW4+8QL2w3qUNhqPzEvUip6LAZK/wPYvAOuq+bEdvqW1ufNDXFWi2x+qT9uLCvyZ0KwuH35RFqJgn2m21hoTUcK2PKjdZEZrIeF3HboovyyiXfJ/O4u+PuyIPCCaZvg2TVfknxAYmBPjXAtUlTS5D587altmXmVAxU7GV7XFq8ER2V9eTlYa3LY2tX47eWTdejtQiGubDvGM8+NniC7Fh2ZO5BzN2vnTtBkMOWthoUYW0UGLfXzAjo/+i35CTmRQY5sH4ZYS81iLIWOZ/24Z6u8n60IokGe3YtwXb9VpUuOEokSUHqX+T5ry5L1y/1ZcPP0cj8cEdvCA/+P9pHsiZgjEwNy1Jl6SAV8BeTVOrtEFZQctHp3xhfzgyIzV6wboE4KZgZzisPL4uXgb3w0EnbNlZyXGNslD1SddUBVXt0niayRUl2adk6XZMAU2csESxVFkc97f35xcT1Hjk0HLAd4jwzMK/FkOnllUC1v36vuxRRVFoxZ7HJXPGye+NSuQktqyt946GOS9DXc9nM3+38v4XGBVkBT+1e+GY+Suq+XhkLeL/eU/Khz1+SDSy+EUW/vAqsJeWy/VhDo49n++tKzn+J31ne/ydU/wPpOruYrcffKavzrVbqVpST0o81p4gOCb42qzaKeemwYpPY8sTpX8xneemxpL/Khs8sN47cSD5m6TKjFmY8Ct5yRqkw1EycWBv7omzm6LqHRlr0snE72Gf/OzSHcG1374wltA9928SC3+S3Q8uGT1r518U27aqXzYsO17VVkVdTsLmC1Hk5hPzg9KfganCzbqk0riTdoh0XIqEnju7YS/ZvUA7sC3iD43vsnjrG38JvVSmDFMumAj+0dtOaoVWhnSs5CQWa7Pb2t5d0e3ziILf/xwI//oT8flGvvMVzXX+W4dkABfaqjwlmIcVHkZ9IVXVJXoabY1gF0mB+YGMTTInO6Pg90N8Jp8XCBcqf1wB46SZ+WWYm58Rl+YS6uwvUs5Q+9DpcbdCrSXumYYKKw2D+IMbSzAkWJXhcg6BfFY8sUFn4K2/xdVJ+UBfxZ92rJ7H4mgRz4mli+HGetfCpkk+8YOHO6eNdEhXn93/1ulDWWYeOOF9QcxiszxsqdYcSo9LoOss0PrGBCzOq4xa6504Hrcm82eUT+dKJOPIWXuur1v2llxBe5OA2VJvy+ze03mq0rMKPrjPiE6StGL/NaWj8P+jHL33PHGxsXoMDeXoFdVeGnCEXSF+8Qck3Q7jJB+JCLsaJkDCEcH4e57yqjIC4f/lcy3KYDOZP3pW+UnCk/U7Xwg7mKuIfM5kB6RGMrxhe5g3zasCEQXDRq+OnnpUYatYUMIW/o4JEz+FXl11lf4MDu1k7pxScXs8IVPYyQPWJwMR3jgPeX9YAd0z0hIPxN3sICv6/Jeg4kH3+eEicBxxG1E4p2bjApU+dts3gvvrq2k+zIV5xwRUTVSdj18gnjm0HPN4Rh/zh27R5vvz/BxsV13aiB8Tdi8aYtRdqeMB/icBdz2Puo2iTae1IKsWB7w4OvHhP4EVCG/fipbW1uTsKL7309RVgt0eA3bfsTwrS97GgyK26JgZuZaPKJC+fLJ6pyFVJdEJE0pDUPf3BVFMeTlGAhfKFR3ozSfRXSpq+kC9n+LegZXu9G8Ovv6Rm7a0F7UXZ/9BRtbYhCcie5HInWefzIYhEsR/UmiMylU12GXGRn96k2G/6v9c//KDnWDetAB+9c+r309kw5dhZWP+rhRXOJUjhGMbcO+2AeNkMat0yFWTXxRcxoQX4C7NqxQPvF34R69+rq5DTQtuJZYWrkJ9cS0LFowqxCVfWEojeUeu9XQWFK/T3eTSCK2G0jqzgNsiNiYR4LlR12svb8vWw/NJd47EepQIrpNyJZyUaLcN1/uTLGWnxrjkCcCibdv7tMvrecgqV0sz8K/++sPbElUmJ9D8p2eZ3rrbMd4rXVDIRerHeFHf5WH7WD44c9G7DIcb5V0+PkcQzem9doEi0aYtHSVtpSBS6Laizfc84dhYXb8V6CiNyuFm5otuWJHTejAtiu8FJa7jDzos5PFExUGqOg2LM6QueM6iKXJx2mVzeP8P04mhKBtU+DiCl4a4o05hqujIvUfJ0Wk1Ma1w4ezvkkS/pe5rJw+h+y7JJ0/otpyGL1p0Yk5ADo24fNOdHRx/7AL/LS97gu6+dGAFg+PWlz5OjD945NAWhsul5fkgOjc0UYIoEMm4BPHrLrdNeb0jNUZDwCaRRLFoaMiEq3gpRFKXTMpVpbH8ixnKEHZ4mCLRIVEaEetY3YXmC+5ZFH/U5UP849Zd6t22W9zfgZwUpAqtSAlf4yV3WrhXkdbZVRla62g/QSZM0fy1xcVtMn5OUlCDU3y+e97kXmn58u7K8BEHM8oNivSI7q1dafT9qVq6mfKQrfhJy2fE8pzUoiSNKxEq/ZYGNSHOh0cpr90wsY4udpQXnpEX6qwZp6ukdsNk9vDJ4n2S+luGNKuXRrvdWyFVLLHd249s20nz94j3UtliscWIhrntdWF/yd3FO5maEUuxIp9rQMzfg+qAgAfzjMd993bD3cn+3pEzeogoj05SEzdQ9aMEH6eVFK+U3qOC3OfC7WzOiUDaqbagkt+nhohi4ix/yHZITM7E3xX8jJ/C58jkje9PPd7N7N6C/AuIDoGRzcLcSbSg+JIEGUF4p9srWqxG6voP8BABIjF90I63+IFNrj5dEz+jD/1caMUP+ToQVMbGuPCF/FhrpBPRKvKcUQXsQBhoHZet6DlpAorPx3EbRmWXoC4Sc1dZ+y1DrA5ciUHbHDXNwPwsbZ1KcRKcCUfCEMHY903fFyDXEOnRA2mjF40X0Q8H/BEFouwOrm+lr7afX0C7TJOOL4qPQp7vEPzti/1pYppEGcHun1nyH81363eS5THgnL6y1qEEJr8Aaa8RblrGovBmmPLzWq/u5tH9OIUfHrVU56C2eRTq9Unq0xPkggSJY5mlxdkVyh6dG7X1TEjwwX0zvwoyeS8uw02Bm9RHCw3fzzv/hXuzqLQVLoN5xyLgCNxQxZhREyvV/aRaHoy6IzKw7rCz2RmHrQOcgZAAq1UD6+vilALNq6TUkB/c77G/hlleZ9KNCE6E9WD/Nw276wajltC5ijxnL8Wyt5PzTBXRM0qv4f1EHfViFv5wbGe1thHy3bXbZkD9rR47vbd32njpps0s4aR9e/N0qlSfyFoR7y/q7nlRPLIO8R8YcTobcUVQF/T+eT1T9u67tFnws61ylY38nIyya8vp7aIs+0Wr7ONPymb+jttufpNzacxv6efvvnp7w2mXVLjkWApRUaMqI5qO8qBteaeRjfs+q6i1eMLtwhcMLbaLRW2jR/1lgxqlvDGcLA3wtErpLgvG1fq+ZnvZZOZhLO2rm7t4H9hnYO+2mVWfAStC7pa7Cu3grxDuq8/KtBNv/FQFNCB7n+U3Ld6lbAo6AXxL9zD/A8W2c97B5iNuI0pOVNwJHvKaeDtvwoec/3nei7ajq6EVe1sTfqv9tmWTeL8nvcQoVHlhxFf20jegvE3jbP+89j9TDL2aducRDAY+NvWIX4sH7r4tdiH0YweuMwhDUKCthtIQ/tXgWV5x+D7HSDQsPyYkVKShDxfzgykiTEBZyFAWoLkDPDAQAIhURJBAiHKnBcMSLFgMar+0FIhRoIsVVcx+SRHMovSpX0GCeRSsxep3ZQIpyj21FBPIlQ4Lxk+gKX8DwcLz+kEUvMQSP/2uBpZ5RBD21k+kdYpOcKEGz0foLivkY+As4B6a7hkWobquCD2+uDmjzEHp/MuvXgao1G8Qay5DAK8HgBslg0LrF9S2cz9fJk4kBxgo0oxwq3HNRO4wlUCYwg8Cj7hfofAlHrSlIqPS1UP3RIwy1Zi0VhJQ++sheJeyxIxDxITbcbEbQtVn5D75J17WzzhNs6mO4fmQDdzilVrT4fGwKTKP2bG+K8GtPUMEusX1J0yb7DG5K5DfSsIgIY37Sk5ZAdhWSWa5PWyMCyKP7CEIENKDs6t596jI/wAZ+z/A9+fcabhdzi+/9NbeGTAYBuAZ4Koto88ofVq4Csi46BvXPG9ZCXgL5F8rSo+Rv1ALB6hF+rLLCZwnSDmAU1lwnRSxGDB5KS+gtnCi4wNGHUF4oUSTPIArygWZF5i1Rs58gFQMktWYBsqC5D1ck1yw8keYVdwKAfINwEbPJlHtvxkIhKEgIafLZlNVpPADWoKapX6lgXIyOS01ZiJr2CgcziVE2iq1qVm9GAmS61sdQd74h7jh2pfx11EDt4ekTnAXLFC5C510J9cY2hsO3QMPKrNzjpSu7g1ClyV3SQZM2aH5AvKSaypdiNbWTN1O9+aAkAbiqNMZ1WDc2E7hNUvbaJygHCP4CmmJAgO0sTWURXiCsrt/FJEGDuYqY8KKBwMBBiuEBfXmAKQHAFkeYhvc8hiUOC6PlRKfShyR4RHuXJ7AM2seL4qQnCNTpVqLWiWKFKvH5kmPiy1IgMDJfOAIOaLWsnQBtSoUsOJTq+VoTYcOP/XEar7q9zP70atSgSuYbFIyP44txbW6gTXGmfOxKVWptJJJkKuiQl3WmUSeUVZOGLuuUil/IAIsd7DCAT0vgahnijQop3NW65BFHJxCbux9ZURsmlYkWafEE2PzpJ8AAhW1GzbAl/Qjt161CP4zWUfPjdGl69Xxk2R+lH6q1CriL5GSCgaAlhBkTLy5haR/I8jIKcWIk0JDSyddpgE/6vdNuBAWwh2qUmvyf36AVqdPIzEYMZnpDCaLzeHy+II88hSKxBIpCMGITK5QqtSavLQ6vcGIYjhBUiazxZp5Fm52h9Pl9kCgMDgCiUJjsDg8gUgiU6ip55NlVjQ6wGCyZNXmcHl8gVAklkhloFyhDFRqjTZfOF3G9QajyWyx2uwOZ269efDoyZ2XXO4enl7ePr7+DfK8CkYtFDcdQPZn89+MeBdT1O/2hwKrXHp77FFrKs8O2ONTJN9h5fxSeaCCZrpLAz/Swlp2VM9in13SR8TnDcMQIUCPI5argbFmfDUhGIMsq8Ejr6fWJi5EVE3RFqiHdBk/JS68nhYTlbmK3tOjynVmMP95qw3VvpUYP+EqxOjVBoaZUHWJgllFdXtWSVT3Cpy1ns0pcutC8ddOKFXAb7+ur6E96hV4stFWEn+IF9pcxZfzU+3aAlEk1NcSa/UhUejH+367ZaNYnv6amiTeUcLQStIWhIeQJAypKF2/+DrS8+9b+r84YC1QjYTmWmqtOaQKcws0rrB4vbaZomVftL3zwCbetAtNX0Jfw1D1yzO4hkBoC4PwFgLC1qTBzV416W3aOwJ3tbZWApe7sX3HiM3KAxHboqsFjk/h7nHO13DNXdW3JDX+dYgh+cJmfKKdkKXpH5+Te+m3pXdChEGOvZYmXkh0HZy9deKn7PtuJeuwC8ynEtPecOx0c73CcWprlrk9zYQ2e3xsgX1x7ao=) format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Abril Fatface';
  font-style: normal;
  font-weight: 400;
  src: local('Abril Fatface'), local('AbrilFatface-Regular'), url(data:font/woff2;base64,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BL3+M1K+NfPvjlJEHZTOrkYvtdprqx0Hka+W/IhsQoUJE0jsPVOhV2itgp3Wame8dsB73DeCOfp+FMSxp2At3aozP1zVQ/tmEpXdveum7kat3CaLXRcmTZHmOveMiqxSteCZOrGKmscOa9WycTUXtRFabrtts1Nb3e5qHtqWPMWtuEkMSdydcarhKoTcVXtBgujKwULbPFJvqywIzBjboUacECG6ajlIews5dBUMkJ/LYHa12gpRLEsBDAAA6raxOaTnbx4GG5J6hdn4twxT1DRvEQZvD6banOa3BbstVh48efHmw5cffwECBQkWIvK/LTbhIkSKEi1GrDjxEiRKkixFqjTpMmTKki1Hrjz5ChQqUqxEqTLlKlSqUq2e+hpoqJHGmmiqmeZhWGKoYfaZ7qXhxhtjnlWWxsBotw0xxWdfjDPDSEfc98l8q33z1XeLrXPKCeu10NJErZzR2kmnXXDWOee90sYVF12yQVsfTXLdVde088Y7o3TQXkedddLFQnb/qVGrq24cuuvhtZ5666WPfvraaZEB+htokLfe2+1GBDbalARuuueWzbbYboejttrmmBHW2O+AvUmRDMb6EEUsHHQoDskRjxRIiVRILev2qn1oaGpomZOB2z/jmn/eUk6tvaZda/5znbhPCguQ7wsEvd1strBI3OYR8ye01+ZO0jbH36oqKm37w90hl2v/wO5o3vIjtpoZx20H) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
</style><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><script src="https://cdn.bootcss.com/highlight.js/9.6.0/highlight.min.js" defer></script><script src="/js/paper.js" defer></script><script src="https://www.googletagmanager.com/gtag/js?id=xx-xxxxxxx-xx" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'xx-xxxxxxx-xx');</script><link rel="stylesheet" href="/css/tocbot.css"><script src="/js/tocbot.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.toc__content',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.article__content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: true,
    orderedList: false,
    collapseDepth: 2,
  });
})</script><link rel="preload" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css"><link rel="preload" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="mask-border"></div><div class="head"><div class="head__inner"><h1><a href="/">This is Pequod! Arriving shortly at LZ!</a></h1><p></p></div></div><div class="paper-container"><div class="main"><div class="location-bar"><div class="line-1"><div class="horizontal-line" style="height: 3px"></div></div><div class="line-2"><div class="horizontal-line" style="height: 1px"></div></div><p class="text">手搓STL之pair结构实现</p><div class="switch-button"><input class="container_toggle" type="checkbox" id="switch" name="mode"><label for="switch">Toggle</label></div><div class="line-3"><div class="horizontal-line" style="height: 1px"></div></div></div><div class="main__2-col"><article class="post-view__article"><div class="article__infomation"><div class="posts-item"><h2 class="posts-item__title"><a href="">手搓STL之pair结构实现</a></h2><span class="post__date">2025-09-22</span><a href="/tags/C/"><span class="post__tags">#C++</span></a><a href="/tags/STL/"><span class="post__tags">#STL</span></a></div></div><div class="article__content"><h1 id="实现pair并实现STL中utility的核心功能的几个功能"><a href="#实现pair并实现STL中utility的核心功能的几个功能" class="headerlink" title="实现pair并实现STL中utility的核心功能的几个功能"></a>实现pair并实现STL中<code>utility</code>的核心功能的几个功能</h1><p>包含移动语义、完美转发、交换操作和<code>pair</code>结构体等基础工具。以下是详细分析：</p>
<h1 id="代码环节"><a href="#代码环节" class="headerlink" title="代码环节"></a>代码环节</h1><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYTINYSTL_UTIL_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYTINYSTL_UTIL_H_</span><br><br><span class="hljs-comment">// 这个文件包含一些通用工具，包括 move, forward, swap 等函数，以及 pair 等 </span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_traits.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> solidstl<br>&#123;<br><br><span class="hljs-comment">// move</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; arg)</span> <span class="hljs-keyword">noexcept</span> <span class="hljs-comment">// typename 是告诉编译器 std::remove_reference&lt;T&gt;::type&amp;&amp; 是一个类型名</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 去掉T的引用类型然后加上两个&amp;变成右值引用然后再强转arg的类型</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(arg); <span class="hljs-comment">// static_cast&lt;目标类型&gt;(表达式)，用于在**编译时**执行类型转换，类似 C 语言的隐式转换或显式强制转换，但更规范</span><br>&#125;<br><br><span class="hljs-comment">// forward</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    这里是对forward做了一个重载，一般在使用forward之前我们通过万能引用先获取了对应的左值引用或者右值引用。</span><br><span class="hljs-comment">    比如T&amp;&amp; param，但是就算param是一个右值引用类型的变量，它有名字，就是一个左值，所以调用forward&lt;T&gt;(param)时，</span><br><span class="hljs-comment">    使用的还是第一个重载，因为只有第一个重载的typename std::remove_reference&lt;T&gt;::type&amp;这个左值引用可以匹配左值。</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    只有在foward&lt;T&gt;(右值)时会匹配第二个重载，且这里的T是左值引用类型时编译时会错误。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp; arg)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(arg);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp; arg)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">static_assert</span>(!std::is_lvalue_reference&lt;T&gt;::value, <span class="hljs-string">&quot;bad forward&quot;</span>); <span class="hljs-comment">// 强制检查模板参数T不能是左值引用类型（T&amp;）。若违反，编译时会触发断言错误，防止错误地将右值转发为左值。</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(arg);<br>&#125;<br><br><span class="hljs-comment">// swap</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    利用`move`实现高效交换，避免三次拷贝（仅三次移动）。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Tp</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Tp&amp; lhs, Tp&amp; rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">tmp</span><span class="hljs-params">(solidstl::move(lhs))</span></span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    如果自定义类型Tp定义了移动构造函数:</span><br><span class="hljs-comment">    此时tmp的初始化形式为Tp tmp(Tp&amp;&amp;)，</span><br><span class="hljs-comment">    会优先匹配移动构造函数，触发 “移动拷贝”—— 即通过移动构造函数将lhs的资源（如堆内存、文件句柄等）转移到tmp中，避免深拷贝，提升性能</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    如果自定义类型Tp没有定义移动构造函数，但定义了拷贝构造函数：</span><br><span class="hljs-comment">    此时右值引用（Tp&amp;&amp;）可以隐式转换为const Tp&amp;（常量左值引用），tmp的初始化会匹配拷贝构造函数Tp tmp(const Tp&amp;)，触发 “拷贝构造”（而非移动）。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    如果自定义类型Tp既没有移动构造也没有拷贝构造：</span><br><span class="hljs-comment">    编译器会生成默认的移动构造函数（C++11 及以上），此时tmp的初始化会调用默认移动构造函数，</span><br><span class="hljs-comment">    执行 “浅拷贝”（对基本类型成员直接复制，对指针成员仅复制地址，可能导致资源管理问题）。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    当Tp是基本类型（如int）时:</span><br><span class="hljs-comment">    solidstl::move(lhs)将int&amp;（左值）转换为int&amp;&amp;（右值引用），但这仅改变值类别，不影响实际数据。</span><br><span class="hljs-comment">    auto tmp(...)的初始化会直接将lhs的值复制到tmp中（与int tmp = lhs的效果完全一致）。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    也就是说，只讨论自定义类型，如果类型没有定义移动构造，那么性能和不使用move一样</span><br><span class="hljs-comment">*/</span><br>  lhs = solidstl::<span class="hljs-built_in">move</span>(rhs);<br>  rhs = solidstl::<span class="hljs-built_in">move</span>(tmp);<br>&#125;<br><br><span class="hljs-comment">// 交换两个迭代器范围内的元素（如两个数组的对应元素）。第一个范围由 [first1, last1) 定义，第二个范围从 first2 开始，长度与第一个范围相同。</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardIter1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardIter2</span>&gt;<br><span class="hljs-function">ForwardIter2 <span class="hljs-title">swap_range</span><span class="hljs-params">(ForwardIter1 first1, ForwardIter1 last1, ForwardIter2 first2)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (; first1 != last1; ++first1, (<span class="hljs-type">void</span>) ++first2)<br>    solidstl::<span class="hljs-built_in">swap</span>(*first1, *first2);<br>  <span class="hljs-keyword">return</span> first2;<br>&#125;<br><br><span class="hljs-comment">// 重载数组类型的`swap`，通过`swap_range`交换整个数组。</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Tp</span>, <span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Tp(&amp;a)[N], Tp(&amp;b)[N])</span></span><br><span class="hljs-function"></span>&#123;<br>  solidstl::<span class="hljs-built_in">swap_range</span>(a, a + N, b);<br>&#125;<br><br><span class="hljs-comment">// --------------------------------------------------------------------------------------</span><br><span class="hljs-comment">// pair</span><br><br><span class="hljs-comment">// 结构体模板 : pair</span><br><span class="hljs-comment">// 两个模板参数分别表示两个数据的类型</span><br><span class="hljs-comment">// 用 first 和 second 来分别取出第一个数据和第二个数据</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty2</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span><br>&#123;<br>  <span class="hljs-keyword">typedef</span> Ty1    first_type; <span class="hljs-comment">// 第一个元素类型</span><br>  <span class="hljs-keyword">typedef</span> Ty2    second_type; <span class="hljs-comment">// 第二个元素类型</span><br><br>  first_type first;    <span class="hljs-comment">// 保存第一个数据</span><br>  second_type second;  <span class="hljs-comment">// 保存第二个数据</span><br><br>  <span class="hljs-comment">// 构造函数（多版本重载）</span><br><br>  <span class="hljs-comment">// default constructiable 默认构造,仅当两个模板元素类型都可默认构造时启用</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Other1</span> = Ty1, <span class="hljs-keyword">class</span> Other2 = Ty2,<br>    <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>    std::is_default_constructible&lt;Other1&gt;::value &amp;&amp;<br>    std::is_default_constructible&lt;Other2&gt;::value, <span class="hljs-type">void</span>&gt;::type&gt;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">pair</span>() <span class="hljs-comment">// 构造函数关键字constexpr,表示该构造函数可以在编译期执行</span><br>    : <span class="hljs-built_in">first</span>(), <span class="hljs-built_in">second</span>()<br>  &#123;<br>  &#125;<br><br>  <span class="hljs-comment">// implicit constructiable for this type  可隐式转换同类型参数构造</span><br>  <span class="hljs-comment">// 带条件的拷贝构造函数模板，仅当模板参数满足，</span><br>  <span class="hljs-comment">// 允许通过 Ty1 和 Ty2 类型（或可隐式转换为它们的类型）的参数构造 pair 对象</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> U1 = Ty1, <span class="hljs-keyword">class</span> U2 = Ty2,<br>    <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>    std::is_copy_constructible&lt;U1&gt;::value &amp;&amp; <span class="hljs-comment">// std::is_copy_constructible&lt;U&gt; 判断类型 U 是否有可用的拷贝构造函数</span><br>    std::is_copy_constructible&lt;U2&gt;::value &amp;&amp;<br>    std::is_convertible&lt;<span class="hljs-type">const</span> U1&amp;, Ty1&gt;::value &amp;&amp; <span class="hljs-comment">// std::is_convertible&lt;From, To&gt; 判断 From 类型是否可隐式转换为 To 类型</span><br>    std::is_convertible&lt;<span class="hljs-type">const</span> U2&amp;, Ty2&gt;::value, <span class="hljs-type">int</span>&gt;::type = <span class="hljs-number">0</span>&gt;<br>    <span class="hljs-comment">// 当条件为 true 时，std::enable_if&lt;..., int&gt;::type 是 int 类型，因此模板参数等价于 int = 0（合法的默认参数）。</span><br>    <span class="hljs-comment">// 当条件为 false 时，::type 不存在，模板参数声明无效，触发 SFINAE，该构造函数被编译器忽略。</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">pair</span>(<span class="hljs-type">const</span> Ty1&amp; a, <span class="hljs-type">const</span> Ty2&amp; b)<br>    : <span class="hljs-built_in">first</span>(a), <span class="hljs-built_in">second</span>(b)<br>  &#123;<br>  &#125;<br><br>  <span class="hljs-comment">// explicit constructible for this type 不可隐式转换同类型参数构造</span><br>  <span class="hljs-comment">// 仅当 U1 或 U2 不能隐式转换为 Ty1 或 Ty2 时启用</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> U1 = Ty1, <span class="hljs-keyword">class</span> U2 = Ty2,<br>    <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>    std::is_copy_constructible&lt;U1&gt;::value &amp;&amp;<br>    std::is_copy_constructible&lt;U2&gt;::value &amp;&amp;<br>    (!std::is_convertible&lt;<span class="hljs-type">const</span> U1&amp;, Ty1&gt;::value ||<br>     !std::is_convertible&lt;<span class="hljs-type">const</span> U2&amp;, Ty2&gt;::value), <span class="hljs-type">int</span>&gt;::type = <span class="hljs-number">0</span>&gt;<br>    <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">pair</span>(<span class="hljs-type">const</span> Ty1&amp; a, <span class="hljs-type">const</span> Ty2&amp; b) <span class="hljs-comment">// explicit 修饰，只能显式调用，禁止隐式转换；</span><br>    : <span class="hljs-built_in">first</span>(a), <span class="hljs-built_in">second</span>(b)<br>  &#123;<br>  &#125;<br>  <span class="hljs-comment">// 拷贝构造函数显式默认化声明,编译器生成默认版本</span><br>  <span class="hljs-built_in">pair</span>(<span class="hljs-type">const</span> pair&amp; rhs) = <span class="hljs-keyword">default</span>; <br>  <br>  <span class="hljs-comment">// 移动构造函数显式默认化声明,编译器生成默认版本</span><br>  <span class="hljs-built_in">pair</span>(pair&amp;&amp; rhs) = <span class="hljs-keyword">default</span>; <br><br>  <span class="hljs-comment">// implicit constructiable for other type</span><br>  <span class="hljs-comment">// 用任意类型 Other1 和 Other2 的参数（左值或右值）构造 pair 对象，只要这些参数能安全地构造并隐式转换为 Ty1 和 Ty2 类型</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Other1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Other2</span>,<br>    <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>    std::is_constructible&lt;Ty1, Other1&gt;::value &amp;&amp;<br>    std::is_constructible&lt;Ty2, Other2&gt;::value &amp;&amp;<br>    std::is_convertible&lt;Other1&amp;&amp;, Ty1&gt;::value &amp;&amp;<br>    std::is_convertible&lt;Other2&amp;&amp;, Ty2&gt;::value, <span class="hljs-type">int</span>&gt;::type = <span class="hljs-number">0</span>&gt;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">pair</span>(Other1&amp;&amp; a, Other2&amp;&amp; b)<br>    : <span class="hljs-built_in">first</span>(solidstl::forward&lt;Other1&gt;(a)), <span class="hljs-comment">// 通过完美转发（perfect forwarding）优化性能，避免不必要的拷贝。</span><br>    <span class="hljs-built_in">second</span>(solidstl::forward&lt;Other2&gt;(b))<br>  &#123;<br>  &#125;<br><br>  <span class="hljs-comment">// explicit constructiable for other type</span><br>  <span class="hljs-comment">// 可以安全构造但不能隐式转换的需要显式调用</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Other1, <span class="hljs-keyword">class</span> Other2,<br>    <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>    std::is_constructible&lt;Ty1, Other1&gt;::value &amp;&amp;<br>    std::is_constructible&lt;Ty2, Other2&gt;::value &amp;&amp;<br>    (!std::is_convertible&lt;Other1, Ty1&gt;::value ||<br>     !std::is_convertible&lt;Other2, Ty2&gt;::value), <span class="hljs-type">int</span>&gt;::type = <span class="hljs-number">0</span>&gt;<br>    <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">pair</span>(Other1&amp;&amp; a, Other2&amp;&amp; b)<br>    : <span class="hljs-built_in">first</span>(solidstl::forward&lt;Other1&gt;(a)),<br>    <span class="hljs-built_in">second</span>(solidstl::forward&lt;Other2&gt;(b))<br>  &#123;<br>  &#125;<br><br>  <span class="hljs-comment">// implicit constructiable for other pair</span><br>  <span class="hljs-comment">// 从其他 pair 的 const 左值引用隐式构造</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Other1, <span class="hljs-keyword">class</span> Other2,<br>    <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>    std::is_constructible&lt;Ty1, <span class="hljs-type">const</span> Other1&amp;&gt;::value &amp;&amp; <span class="hljs-comment">// Ty1可由const Other1&amp;构造</span><br>    std::is_constructible&lt;Ty2, <span class="hljs-type">const</span> Other2&amp;&gt;::value &amp;&amp; <span class="hljs-comment">// Ty2可由const Other2&amp;构造</span><br>    std::is_convertible&lt;<span class="hljs-type">const</span> Other1&amp;, Ty1&gt;::value &amp;&amp; <span class="hljs-comment">// const Other1&amp;可隐式转换为Ty1</span><br>    std::is_convertible&lt;<span class="hljs-type">const</span> Other2&amp;, Ty2&gt;::value, <span class="hljs-type">int</span>&gt;::type = <span class="hljs-number">0</span>&gt; <span class="hljs-comment">// const Other2&amp;可隐式转换为Ty2</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">pair</span>(<span class="hljs-type">const</span> pair&lt;Other1, Other2&gt;&amp; other)<br>    : <span class="hljs-built_in">first</span>(other.first),<br>    <span class="hljs-built_in">second</span>(other.second)<br>  &#123;<br>  &#125;<br><br>  <span class="hljs-comment">// explicit constructiable for other pair</span><br>  <span class="hljs-comment">// 从其他 pair 的 const 左值引用显式构造</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Other1, <span class="hljs-keyword">class</span> Other2,<br>    <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>    std::is_constructible&lt;Ty1, <span class="hljs-type">const</span> Other1&amp;&gt;::value &amp;&amp;<br>    std::is_constructible&lt;Ty2, <span class="hljs-type">const</span> Other2&amp;&gt;::value &amp;&amp;<br>    (!std::is_convertible&lt;<span class="hljs-type">const</span> Other1&amp;, Ty1&gt;::value ||<br>     !std::is_convertible&lt;<span class="hljs-type">const</span> Other2&amp;, Ty2&gt;::value), <span class="hljs-type">int</span>&gt;::type = <span class="hljs-number">0</span>&gt;<br>    <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">pair</span>(<span class="hljs-type">const</span> pair&lt;Other1, Other2&gt;&amp; other)<br>    : <span class="hljs-built_in">first</span>(other.first),<br>    <span class="hljs-built_in">second</span>(other.second)<br>  &#123;<br>  &#125;<br><br>  <span class="hljs-comment">// implicit constructiable for other pair</span><br>  <span class="hljs-comment">// 从其他 pair 的右值引用隐式构造</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Other1, <span class="hljs-keyword">class</span> Other2,<br>    <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>    std::is_constructible&lt;Ty1, Other1&gt;::value &amp;&amp;<br>    std::is_constructible&lt;Ty2, Other2&gt;::value &amp;&amp;<br>    std::is_convertible&lt;Other1, Ty1&gt;::value &amp;&amp;<br>    std::is_convertible&lt;Other2, Ty2&gt;::value, <span class="hljs-type">int</span>&gt;::type = <span class="hljs-number">0</span>&gt;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">pair</span>(pair&lt;Other1, Other2&gt;&amp;&amp; other)<br>    : <span class="hljs-built_in">first</span>(solidstl::forward&lt;Other1&gt;(other.first)),<br>    <span class="hljs-built_in">second</span>(solidstl::forward&lt;Other2&gt;(other.second))<br>  &#123;<br>  &#125;<br><br>  <span class="hljs-comment">// explicit constructiable for other pair</span><br>  <span class="hljs-comment">// 从其他 pair 的右值引用显示构造</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Other1, <span class="hljs-keyword">class</span> Other2,<br>    <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>    std::is_constructible&lt;Ty1, Other1&gt;::value &amp;&amp;<br>    std::is_constructible&lt;Ty2, Other2&gt;::value &amp;&amp;<br>    (!std::is_convertible&lt;Other1, Ty1&gt;::value ||<br>     !std::is_convertible&lt;Other2, Ty2&gt;::value), <span class="hljs-type">int</span>&gt;::type = <span class="hljs-number">0</span>&gt;<br>    <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">pair</span>(pair&lt;Other1, Other2&gt;&amp;&amp; other)<br>    : <span class="hljs-built_in">first</span>(solidstl::forward&lt;Other1&gt;(other.first)),<br>    <span class="hljs-built_in">second</span>(solidstl::forward&lt;Other2&gt;(other.second))<br>  &#123;<br>  &#125;<br><br><br>  <span class="hljs-comment">// 所有赋值运算符重载均返回 *this 的引用，因此支持链式操作</span><br><br>  <span class="hljs-comment">// copy assign for this pair</span><br>  <span class="hljs-comment">// 同类型拷贝赋值</span><br>  pair&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> pair&amp; rhs)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs)<br>    &#123;<br>      first = rhs.first;<br>      second = rhs.second;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// move assign for this pair</span><br>  <span class="hljs-comment">// 同类型移动赋值</span><br>  pair&amp; <span class="hljs-keyword">operator</span>=(pair&amp;&amp; rhs) <span class="hljs-comment">// 右值引用</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs)<br>    &#123;<br>      first = solidstl::<span class="hljs-built_in">move</span>(rhs.first);<br>      second = solidstl::<span class="hljs-built_in">move</span>(rhs.second);<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// copy assign for other pair</span><br>  <span class="hljs-comment">// 其他类型 pair 的拷贝赋值</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Other1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Other2</span>&gt;<br>  pair&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> pair&lt;Other1, Other2&gt;&amp; other)<br>  &#123;<br>    first = other.first;<br>    second = other.second;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// move assign for other pair</span><br>  <span class="hljs-comment">// 其他类型 pair 的移动赋值</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Other1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Other2</span>&gt;<br>  pair&amp; <span class="hljs-keyword">operator</span>=(pair&lt;Other1, Other2&gt;&amp;&amp; other)<br>  &#123;<br>    first = solidstl::forward&lt;Other1&gt;(other.first);<br>    second = solidstl::forward&lt;Other2&gt;(other.second);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  ~<span class="hljs-built_in">pair</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 默认析构</span><br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(pair&amp; other)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other)<br>    &#123;<br>      solidstl::<span class="hljs-built_in">swap</span>(first, other.first);<br>      solidstl::<span class="hljs-built_in">swap</span>(second, other.second);<br>    &#125;<br>  &#125;<br><br>&#125;;<br><br><span class="hljs-comment">// 重载比较操作符 </span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty2</span>&gt;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> pair&lt;Ty1, Ty2&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;Ty1, Ty2&gt;&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">return</span> lhs.first == rhs.first &amp;&amp; lhs.second == rhs.second;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty2</span>&gt;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> pair&lt;Ty1, Ty2&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;Ty1, Ty2&gt;&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">return</span> lhs.first &lt; rhs.first || (lhs.first == rhs.first &amp;&amp; lhs.second &lt; rhs.second);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty2</span>&gt;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> pair&lt;Ty1, Ty2&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;Ty1, Ty2&gt;&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">return</span> !(lhs == rhs);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty2</span>&gt;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> pair&lt;Ty1, Ty2&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;Ty1, Ty2&gt;&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">return</span> rhs &lt; lhs;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty2</span>&gt;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> pair&lt;Ty1, Ty2&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;Ty1, Ty2&gt;&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">return</span> !(rhs &lt; lhs);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty2</span>&gt;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> pair&lt;Ty1, Ty2&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;Ty1, Ty2&gt;&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">return</span> !(lhs &lt; rhs);<br>&#125;<br><br><span class="hljs-comment">// 重载 solidstl 的 swap</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty2</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(pair&lt;Ty1, Ty2&gt;&amp; lhs, pair&lt;Ty1, Ty2&gt;&amp; rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>  lhs.<span class="hljs-built_in">swap</span>(rhs);<br>&#125;<br><br><span class="hljs-comment">// 全局函数，让两个数据成为一个 pair</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty2</span>&gt;<br><span class="hljs-function">pair&lt;Ty1, Ty2&gt; <span class="hljs-title">make_pair</span><span class="hljs-params">(Ty1&amp;&amp; first, Ty2&amp;&amp; second)</span> <span class="hljs-comment">// 万能引用</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">pair</span>&lt;Ty1, Ty2&gt;(solidstl::forward&lt;Ty1&gt;(first), solidstl::forward&lt;Ty2&gt;(second)); <span class="hljs-comment">// 完美转发</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// !MYTINYSTL_UTIL_H_</span></span><br><br><br></code></pre></td></tr></table></figure>

<h1 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h1><h2 id="static-cast-如何使用"><a href="#static-cast-如何使用" class="headerlink" title="static_cast 如何使用"></a>static_cast 如何使用</h2><p><code>static_cast</code> 是 C++ 中最常用的类型转换运算符之一，用于在<strong>编译时</strong>执行类型转换，适用于多种“逻辑上合理”的类型转换场景。它的语法形式为：<br><code>static_cast&lt;目标类型&gt;(表达式)</code>  </p>
<h3 id="主要使用场景及示例"><a href="#主要使用场景及示例" class="headerlink" title="主要使用场景及示例"></a>主要使用场景及示例</h3><h4 id="1-基本数据类型之间的转换（数值类型转换）"><a href="#1-基本数据类型之间的转换（数值类型转换）" class="headerlink" title="1. 基本数据类型之间的转换（数值类型转换）"></a>1. 基本数据类型之间的转换（数值类型转换）</h4><p>这是最基础的用法，用于内置数据类型（如 <code>int</code>、<code>float</code>、<code>char</code> 等）之间的转换，类似 C 语言的隐式转换或显式强制转换，但更规范。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> b = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(a);  <span class="hljs-comment">// int -&gt; double（安全转换）</span><br><br><span class="hljs-type">float</span> c = <span class="hljs-number">3.14f</span>;<br><span class="hljs-type">int</span> d = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(c);        <span class="hljs-comment">// float -&gt; int（会截断小数部分，结果为3）</span><br><br><span class="hljs-type">char</span> e = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-number">65</span>);     <span class="hljs-comment">// int -&gt; char（ASCII码65对应&#x27;A&#x27;）</span><br>```  <br><br><br>#### <span class="hljs-number">2.</span> 类层次结构中的“上行转换”（派生类 → 基类）  <br>在继承关系中，将派生类指针/引用转换为基类指针/引用（即“向上转型”），这是**安全的**（因为派生类包含基类的所有成员）。  <br><br>```cpp<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;&#125;;  <span class="hljs-comment">// Derived是Base的派生类</span><br><br>Derived d;<br><span class="hljs-comment">// 派生类对象指针 → 基类指针（安全）</span><br>Base* base_ptr = <span class="hljs-built_in">static_cast</span>&lt;Base*&gt;(&amp;d);  <br><br><span class="hljs-comment">// 派生类对象引用 → 基类引用（安全）</span><br>Base&amp; base_ref = <span class="hljs-built_in">static_cast</span>&lt;Base&amp;&gt;(d);  <br>```  <br><br><br>#### <span class="hljs-number">3.</span> 类层次结构中的“下行转换”（基类 → 派生类）  <br>将基类指针/引用转换为派生类指针/引用（即“向下转型”）。**注意：这是不安全的**，因为 `<span class="hljs-keyword">static_cast</span>` 不进行运行时类型检查，仅在编译时验证类型是否相关（是否为同一继承体系）。  <br><br>如果基类指针实际指向的是派生类对象，转换后可正常使用；如果指向的是基类对象，转换后使用可能导致未定义行为。  <br><br>```cpp<br>Base b;<br>Derived* der_ptr = <span class="hljs-built_in">static_cast</span>&lt;Derived*&gt;(&amp;b);  <span class="hljs-comment">// 编译通过，但实际不安全！</span><br><span class="hljs-comment">// 若基类指针实际指向派生类对象，则安全：</span><br>Base* b_ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();  <span class="hljs-comment">// b_ptr实际指向Derived对象</span><br>Derived* d_ptr = <span class="hljs-built_in">static_cast</span>&lt;Derived*&gt;(b_ptr);  <span class="hljs-comment">// 安全，可正常使用d_ptr</span><br>```  <br><br>&gt; 提示：若需安全的下行转换，应使用 `<span class="hljs-keyword">dynamic_cast</span>`（需基类含虚函数，会进行运行时检查）。  <br><br><br>#### <span class="hljs-number">4.</span> 空指针（`<span class="hljs-type">void</span>*`）与其他类型指针的转换  <br>`<span class="hljs-keyword">static_cast</span>` 可将 `<span class="hljs-type">void</span>*` 转换为任意类型的指针（需确保转换合法），也可将任意类型指针转换为 `<span class="hljs-type">void</span>*`。  <br><br>```cpp<br><span class="hljs-type">int</span> x = <span class="hljs-number">100</span>;<br><span class="hljs-type">void</span>* void_ptr = &amp;x;  <span class="hljs-comment">// 任意指针可隐式转换为void*</span><br><br><span class="hljs-comment">// void* → int*（需显式转换）</span><br><span class="hljs-type">int</span>* int_ptr = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(void_ptr);  <br>```  <br><br><br>#### <span class="hljs-number">5.</span> 引用类型的转换  <br>与指针类似，`<span class="hljs-keyword">static_cast</span>` 也可用于引用的类型转换（遵循与指针相同的规则）。  <br><br>```cpp<br>Derived der;<br>Base&amp; base_ref = <span class="hljs-built_in">static_cast</span>&lt;Base&amp;&gt;(der);  <span class="hljs-comment">// 派生类引用 → 基类引用（安全）</span><br><br>Base base;<br>Derived&amp; der_ref = <span class="hljs-built_in">static_cast</span>&lt;Derived&amp;&gt;(base);  <span class="hljs-comment">// 基类引用 → 派生类引用（不安全）</span><br>```  <br><br><br>#### <span class="hljs-number">6.</span> 转换为“右值引用”（用于移动语义）  <br>在实现移动构造或移动赋值时，`<span class="hljs-keyword">static_cast</span>` 可将左值转换为右值引用，配合 `std::move` 使用（`std::move` 本质就是封装了 `<span class="hljs-keyword">static_cast</span>&lt;T&amp;&amp;&gt;`）。  <br><br>```cpp<br>std::string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-comment">// 将左值s1转换为右值引用，触发移动构造</span><br>std::string s2 = <span class="hljs-built_in">static_cast</span>&lt;std::string&amp;&amp;&gt;(s1);  <br>```  <br><br><br>### 不能使用 `<span class="hljs-keyword">static_cast</span>` 的场景  <br>- 不能移除变量的 `<span class="hljs-type">const</span>` 或 `<span class="hljs-keyword">volatile</span>` 属性（需用 `<span class="hljs-keyword">const_cast</span>`）。  <br>  ```cpp<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>  <span class="hljs-comment">// 错误：static_cast不能移除const</span><br>  <span class="hljs-comment">// int* p = static_cast&lt;int*&gt;(&amp;x); </span><br>  ```  <br>- 不能在**无继承关系的类**之间转换指针/引用（需用 `<span class="hljs-keyword">reinterpret_cast</span>`，但风险极高）。  <br>  ```cpp<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;&#125;;<br>  A a;<br>  <span class="hljs-comment">// 错误：A和B无继承关系，不能用static_cast转换</span><br>  <span class="hljs-comment">// B* b_ptr = static_cast&lt;B*&gt;(&amp;a); </span><br>  ```  <br><br><br>### 总结  <br>`<span class="hljs-keyword">static_cast</span>` 的核心特点是：  <br><span class="hljs-number">1.</span> **编译时转换**，无运行时开销；  <br><span class="hljs-number">2.</span> 仅支持“逻辑上合理”的转换（如数值转换、继承体系内转换等）；  <br><span class="hljs-number">3.</span> 不进行运行时类型检查，需开发者自行保证转换的安全性。  <br><br>使用时需根据场景判断是否合适，避免在下行转换或无关类型间滥用。<br><br><br>## 什么是SFINAE<br><br>SFINAE 是 C++ 模板编程中的一个核心机制，全称是 **Substitution Failure Is Not An Error**（替换失败不是错误）。它的核心思想是：当编译器尝试将模板参数替换为具体类型时，如果替换过程中出现失败（如类型不匹配、成员不存在等），这种失败不会被视为编译错误，而是会让编译器忽略这个候选模板，继续查找其他可能匹配的模板。<br><br><br>### 举个简单例子理解<br>假设我们有两个函数模板重载：<br>```cpp<br><span class="hljs-comment">// 模板1：接受任意类型T，尝试调用T的print()方法</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    t.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 若T没有print()方法，这里会在替换时失败</span><br>&#125;<br><br><span class="hljs-comment">// 模板2：通用 fallback，接受任意类型</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    std::cout &lt;&lt; t &lt;&lt; std::endl; <span class="hljs-comment">// 假设T可被输出</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我们调用 <code>print(42)</code> 时：</p>
<ul>
<li>编译器先尝试实例化模板1：用 <code>int</code> 替换 <code>T</code>，发现 <code>int</code> 没有 <code>print()</code> 方法，替换失败。</li>
<li>根据 SFINAE，这种失败不会报错，编译器会继续尝试模板2：<code>int</code> 可以被 <code>cout</code> 输出，实例化成功，最终调用模板2。</li>
</ul>
<h3 id="关键特点"><a href="#关键特点" class="headerlink" title="关键特点"></a>关键特点</h3><ol>
<li><p><strong>仅适用于模板参数替换阶段</strong>：失败必须发生在“用具体类型替换模板参数”的过程中，而不是语法错误（如拼写错误）。</p>
</li>
<li><p><strong>目的是模板重载决议</strong>：SFINAE 允许编译器在多个候选模板中选择“唯一可行”的那一个，而不是遇到第一个失败就报错。</p>
</li>
<li><p><strong>是模板元编程的基础</strong>：许多高级特性（如类型判断、条件编译）都依赖 SFINAE 实现。例如标准库中的 <code>std::enable_if</code>，就是通过 SFINAE 控制模板是否启用。</p>
</li>
</ol>
<h3 id="典型应用：std-enable-if"><a href="#典型应用：std-enable-if" class="headerlink" title="典型应用：std::enable_if"></a>典型应用：<code>std::enable_if</code></h3><p><code>std::enable_if</code> 是 SFINAE 的经典应用，它可以根据条件“启用”或“禁用”某个模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 仅当T是整数类型时，这个函数模板才会被启用</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, <span class="hljs-type">void</span>&gt;::<span class="hljs-function">type</span><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;整数类型: &quot;</span> &lt;&lt; t &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 仅当T是浮点数类型时，这个函数模板才会被启用</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, <span class="hljs-type">void</span>&gt;::<span class="hljs-function">type</span><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;浮点数类型: &quot;</span> &lt;&lt; t &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用 <code>foo(5)</code> 时，<code>std::is_integral&lt;int&gt;</code> 为真，第一个模板被启用；调用 <code>foo(3.14)</code> 时，第二个模板被启用。如果条件不满足（如 <code>T</code> 是 <code>std::string</code>），<code>enable_if</code> 的 <code>::type</code> 不存在，替换失败，该模板被忽略（而非报错）。</p>
<h3 id="分析typename-std-enable-if-type语法"><a href="#分析typename-std-enable-if-type语法" class="headerlink" title="分析typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, void&gt;::type语法"></a>分析typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, void&gt;::type语法</h3><ol>
<li>std::is_integral<T>::value：判断类型是否为整数</li>
<li>std::enable_if&lt;条件, 类型&gt;::type：根据条件决定是否存在类型<br>std::enable_if 是一个模板结构体，它的行为由第一个模板参数（条件）决定，定义简化如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">  <span class="hljs-comment">// 主模板：条件为false时，没有type成员</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span> Condition, <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResultType</span> = <span class="hljs-type">void</span>&gt;<br>  <span class="hljs-keyword">struct</span> enable_if &#123;&#125;;<br><br>  <span class="hljs-comment">// 特化模板：条件为true时，包含type成员，类型为ResultType</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ResultType</span>&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">enable_if</span>&lt;<span class="hljs-literal">true</span>, ResultType&gt; &#123;<br>    <span class="hljs-keyword">using</span> type = ResultType; <span class="hljs-comment">// 仅当条件为true时存在</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>因此：</p>
<p>当第一个参数（std::is_integral<T>::value）为 true 时，std::enable_if&lt;…, void&gt;::type 存在，且类型为 void（第二个参数指定的类型）。</p>
<p>当条件为 false 时，std::enable_if&lt;…, void&gt;::type不存在（因为主模板没有 type 成员）。</p>
<h3 id="pair中的构造函数"><a href="#pair中的构造函数" class="headerlink" title="pair中的构造函数"></a>pair中的构造函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">  <span class="hljs-keyword">template</span> &lt;<br>          <span class="hljs-keyword">class</span> <span class="hljs-title class_">Other1</span> = Ty1, <span class="hljs-keyword">class</span> Other2 = Ty2, <br>          <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">typename</span> std::enable_if<br>            &lt;<br>              std::is_default_constructible&lt;Other1&gt;::value &amp;&amp;<br>              std::is_default_constructible&lt;Other2&gt;::value,<br>              <span class="hljs-type">void</span><br>            &gt;::type<br>          &gt;<br>  <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">pair</span>() <br>  : <span class="hljs-built_in">first</span>(), <span class="hljs-built_in">second</span>()<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Other1 &#x3D; Ty1和Other2 &#x3D; Ty2：这是两个 “占位” 模板参数，默认值为pair的元素类型Ty1和Ty2。</p>
<p>引入它们的目的是为后续的std::enable_if提供类型检查的载体（避免直接使用Ty1&#x2F;Ty2可能导致的模板替换失败问题）。</p>
<p>这是一个 “匿名” 的默认模板参数，通过std::enable_if实现条件判断：</p>
<p>条件：</p>
<p>std::is_default_constructible<Other1>::value &amp;&amp; std::is_default_constructible<Other2>::value</p>
<p>含义：</p>
<p>检查Other1（即Ty1）和Other2（即Ty2）是否都属于 “可默认构造类型”（即该类型可以通过无参构造函数初始化）。</p>
<p>结果：</p>
<p>若条件为true，std::enable_if会定义type成员（此处为void），模板参数合法，构造函数被启用；<br>若条件为false，std::enable_if无type成员，模板参数替换失败，构造函数被 SFINAE 规则排除（不参与重载决议）。</p>
<p>如果去掉Other1和Other2，直接使用Ty1和Ty2,会导致一个关键问题：SFINAE 机制失效，可能引发无意义的编译错误。</p>
<p>std::enable_if的条件需要依赖于当前模板的参数才能触发 SFINAE（Substitution Failure Is Not An Error，即 “替换失败不是错误”）。</p>
<p>Other1和Other2是当前构造函数模板自己的参数（默认值为Ty1和Ty2），因此enable_if的条件std::is_default_constructible<Other1>依赖于这些参数。</p>
<p>当Other1或Other2不可默认构造时，模板替换失败，编译器会忽略这个构造函数（而不是报错），符合 SFINAE 的预期。</p>
<p>如果去掉Other1和Other2，直接使用Ty1和Ty2，enable_if的条件就变成了依赖于外部的Ty1和Ty2（即pair类模板的参数）。</p>
<p>若Ty1或Ty2不可默认构造，enable_if的条件会直接失效（因为::type不存在），导致构造函数声明本身非法，编译器会直接报错（而非忽略这个构造函数）。</p>
<p>即使用户不需要使用这个默认构造函数（比如用其他构造函数初始化pair），只要Ty1&#x2F;Ty2不可默认构造，编译就会失败，这显然不符合设计意图。</p>
<p>Other1和Other2的作用是让enable_if的条件依赖于当前构造函数的模板参数，从而正确触发 SFINAE 机制 —— 仅在参数可默认构造时启用该构造函数，否则安全地忽略它。</p>
<p>去掉这两个参数会导致 SFINAE 失效，引发不必要的编译错误。</p>
<h3 id="我还是不明白为什么若Ty1或Ty2不可默认构造，enable-if的条件会直接失效，导致构造函数声明本身非法，编译器会直接报错（而非忽略这个构造函数），在我看来Other1等于Ty1，他们没有任何区别。"><a href="#我还是不明白为什么若Ty1或Ty2不可默认构造，enable-if的条件会直接失效，导致构造函数声明本身非法，编译器会直接报错（而非忽略这个构造函数），在我看来Other1等于Ty1，他们没有任何区别。" class="headerlink" title="我还是不明白为什么若Ty1或Ty2不可默认构造，enable_if的条件会直接失效，导致构造函数声明本身非法，编译器会直接报错（而非忽略这个构造函数），在我看来Other1等于Ty1，他们没有任何区别。"></a>我还是不明白为什么若Ty1或Ty2不可默认构造，enable_if的条件会直接失效，导致构造函数声明本身非法，编译器会直接报错（而非忽略这个构造函数），在我看来Other1等于Ty1，他们没有任何区别。</h3><p>要理解这个问题，关键在于区分 “模板参数的所属范围” —— Other1 是构造函数自己的模板参数，而 Ty1 是外部类模板的参数。这一区别直接决定了 enable_if 的失败是否属于 SFINAE 能处理的 “替换失败”。</p>
<p>假设我们有一个简化的 pair 类模板，以及一个不可默认构造的类型 NoDefault（没有默认构造函数）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 不可默认构造的类型（没有默认构造函数）</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NoDefault</span> &#123;<br>    <span class="hljs-built_in">NoDefault</span>(<span class="hljs-type">int</span>) &#123;&#125; <span class="hljs-comment">// 只有带参数的构造函数</span><br>&#125;;<br><br><span class="hljs-comment">// 简化的pair类模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty2</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span> &#123;<br>    Ty1 first;<br>    Ty2 second;<br><br>    <span class="hljs-comment">// 情况1：使用构造函数自己的模板参数Other1/Other2（原代码）</span><br>    <span class="hljs-keyword">template</span> &lt;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Other1</span> = Ty1, <span class="hljs-keyword">class</span> Other2 = Ty2,<br>        <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>            std::is_default_constructible&lt;Other1&gt;::value &amp;&amp;<br>            std::is_default_constructible&lt;Other2&gt;::value,<br>            <span class="hljs-type">void</span><br>        &gt;::type<br>    &gt;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">pair</span>() : <span class="hljs-built_in">first</span>(), <span class="hljs-built_in">second</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 情况2：直接使用类模板参数Ty1/Ty2（去掉Other1/Other2）</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    template &lt;</span><br><span class="hljs-comment">        typename = typename std::enable_if&lt;</span><br><span class="hljs-comment">            std::is_default_constructible&lt;Ty1&gt;::value &amp;&amp;</span><br><span class="hljs-comment">            std::is_default_constructible&lt;Ty2&gt;::value,</span><br><span class="hljs-comment">            void</span><br><span class="hljs-comment">        &gt;::type</span><br><span class="hljs-comment">    &gt;</span><br><span class="hljs-comment">    constexpr pair() : first(), second() &#123;&#125;</span><br><span class="hljs-comment">    */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>现在，当我们声明 pair&lt;NoDefault, int&gt; 时（Ty1&#x3D;NoDefault 不可默认构造，Ty2&#x3D;int 可默认构造），两种情况的结果完全不同：</p>
<ol>
<li>情况 1：使用 Other1&#x2F;Other2（原代码）</li>
</ol>
<p>编译器会尝试实例化构造函数的模板参数：</p>
<p>Other1 的默认值是 Ty1&#x3D;NoDefault，Other2 的默认值是 Ty2&#x3D;int。</p>
<p>检查 std::is_default_constructible<Other1>::value：NoDefault 不可默认构造，结果为 false。</p>
<p>因此 std::enable_if&lt;false, void&gt;::type 不存在（enable_if 主模板没有 type 成员）。</p>
<p>关键：这里的失败是 <strong>“构造函数自己的模板参数（Other1）替换时的失败”</strong>，属于 SFINAE 范畴。编译器会认为 “这个构造函数不匹配当前情况”，直接忽略它，不会报错。</p>
<ol start="2">
<li>情况 2：直接使用 Ty1&#x2F;Ty2</li>
</ol>
<p>此时 enable_if 的条件依赖于类模板的参数（Ty1），而非构造函数自己的模板参数：</p>
<p>检查 std::is_default_constructible<Ty1>::value：Ty1&#x3D;NoDefault 不可默认构造，结果为 false。</p>
<p>因此 std::enable_if&lt;false, void&gt;::type 不存在。</p>
<p>关键：这里的失败是 <strong>“构造函数声明本身的语法错误”</strong>，因为 enable_if&lt;false, …&gt;::type 根本不存在，导致构造函数的返回类型（或模板参数）无法解析。编译器会直接报错（如 “‘type’ is not a member of ‘std::enable_if&lt;false, void&gt;’”），而不是忽略这个构造函数。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SFINAE 是 C++ 模板灵活性的关键机制，它允许编译器在编译时“试错”并选择合适的模板，而不是遇到替换失败就终止编译。这一特性使得 C++ 能够实现复杂的编译时类型判断和函数重载逻辑，是模板元编程、类型 traits 等高级特性的基础。</p>
<h2 id="问题：class-U1-Ty1，那么U1和Ty1是同一个类型，std-is-convertible-value为什么不是必然为true？"><a href="#问题：class-U1-Ty1，那么U1和Ty1是同一个类型，std-is-convertible-value为什么不是必然为true？" class="headerlink" title="问题：class U1 &#x3D; Ty1，那么U1和Ty1是同一个类型，std::is_convertible&lt;const U1&amp;, Ty1&gt;::value为什么不是必然为true？"></a>问题：class U1 &#x3D; Ty1，那么U1和Ty1是同一个类型，std::is_convertible&lt;const U1&amp;, Ty1&gt;::value为什么不是必然为true？</h2><p>比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U1</span> = Ty1, <span class="hljs-keyword">class</span> U2 = Ty2,<br>  <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>  std::is_copy_constructible&lt;U1&gt;::value &amp;&amp;<br>  std::is_copy_constructible&lt;U2&gt;::value &amp;&amp;<br>  (!std::is_convertible&lt;<span class="hljs-type">const</span> U1&amp;, Ty1&gt;::value ||<br>   !std::is_convertible&lt;<span class="hljs-type">const</span> U2&amp;, Ty2&gt;::value), <span class="hljs-type">int</span>&gt;::type = <span class="hljs-number">0</span>&gt;<br>  <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">pair</span>(<span class="hljs-type">const</span> Ty1&amp; a, <span class="hljs-type">const</span> Ty2&amp; b) <span class="hljs-comment">// explicit 修饰，只能显式调用，禁止隐式转换；</span><br>  : <span class="hljs-built_in">first</span>(a), <span class="hljs-built_in">second</span>(b)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然 U1 的默认值是 Ty1（即 class U1 &#x3D; Ty1），但 std::is_convertible&lt;const U1&amp;, Ty1&gt;::value 并不必然为 true。这背后的关键原因是：U1 可以被显式指定为非 Ty1 的类型，且即使 U1 是 Ty1，某些特殊类型（如带 explicit 拷贝构造函数的类型）也会导致隐式转换失败。</p>
<ol>
<li>U1 可以被显式指定为非 Ty1 的类型</li>
</ol>
<p>假设 Ty1 &#x3D; int，但显式指定 U1 &#x3D; std::string：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 显式指定U1为std::string，U2为默认的Ty2</span><br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; p&#123;std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;123&quot;</span>), <span class="hljs-number">3.14</span>&#125;; <br></code></pre></td></tr></table></figure>

<p>此时 U1 &#x3D; std::string，Ty1 &#x3D; int，const std::string&amp; 显然无法隐式转换为 int，因此 std::is_convertible&lt;const U1&amp;, Ty1&gt;::value 为 false。</p>
<ol start="2">
<li>即使 U1 &#x3D; Ty1，隐式转换也可能失败</li>
</ol>
<p>更隐蔽的情况是：即使 U1 使用默认值（即 U1 &#x3D; Ty1），const U1&amp;（即 const Ty1&amp;）到 Ty1 的隐式转换也可能失败。这取决于 Ty1 自身的构造函数是否允许这种转换。</p>
<p>最典型的场景是：Ty1 的拷贝构造函数被声明为 explicit。</p>
<p>C++ 中，隐式转换会依赖 “非 explicit 的构造函数”（包括拷贝构造函数）。如果 Ty1 的拷贝构造函数是 explicit 的，那么 const Ty1&amp; 到 Ty1 的隐式转换会被禁止，此时 std::is_convertible&lt;const Ty1&amp;, Ty1&gt;::value 为 false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-comment">// 情况1：拷贝构造函数非explicit（默认）</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp;) = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 非explicit的拷贝构造函数</span><br>&#125;;<br><br><span class="hljs-comment">// 情况2：拷贝构造函数是explicit</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-built_in">B</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-type">const</span> B&amp;)</span> </span>= <span class="hljs-keyword">default</span>; <span class="hljs-comment">// explicit的拷贝构造函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 对于A：U1=A（默认值），检查const A&amp; → A的转换</span><br>    <span class="hljs-built_in">static_assert</span>(std::is_convertible&lt;<span class="hljs-type">const</span> A&amp;, A&gt;::value, <span class="hljs-string">&quot;A should be convertible&quot;</span>); <span class="hljs-comment">// 成立（true）</span><br><br>    <span class="hljs-comment">// 对于B：U1=B（默认值），检查const B&amp; → B的转换</span><br>    <span class="hljs-built_in">static_assert</span>(!std::is_convertible&lt;<span class="hljs-type">const</span> B&amp;, B&gt;::value, <span class="hljs-string">&quot;B should not be convertible&quot;</span>); <span class="hljs-comment">// 成立（false）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="pair的-构造和-构造有什么区别？"><a href="#pair的-构造和-构造有什么区别？" class="headerlink" title="pair的{}构造和()构造有什么区别？"></a>pair的{}构造和()构造有什么区别？</h2><p>() 构造：直接调用对应的构造函数，按构造函数的参数匹配规则选择最佳重载。</p>
<p>{} 构造（列表初始化）：优先尝试匹配接受 std::initializer_list 的构造函数；若不存在，则退化为调用普通构造函数，但会对隐式类型转换更严格。</p>
<p>若构造函数是 explicit 的：</p>
<p>() 构造：若参数类型与构造函数参数类型可隐式转换，仍可调用（但需确保构造函数逻辑允许）。</p>
<p>{} 构造：若参数需要隐式转换才能匹配 explicit 构造函数，会直接编译报错（禁止隐式转换）。</p>
<h2 id="转换构造参数"><a href="#转换构造参数" class="headerlink" title="转换构造参数"></a>转换构造参数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">a</span>(x)&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 C++ 中，类 C 包含一个接受 int 类型参数的构造函数，这种情况下，C++ 会允许从 int 类型到 C 类型的隐式转换，因为这个单参数构造函数会被视为 “转换构造函数”（converting constructor）。</p>
<p>例如，以下代码是合法的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">a</span>(x) &#123;&#125; <span class="hljs-comment">// 转换构造函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(C c)</span> </span>&#123;<br>    <span class="hljs-comment">// 函数参数为C类型</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    C c1 = <span class="hljs-number">10</span>; <span class="hljs-comment">// 合法：int隐式转换为C类型</span><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">20</span>);  <span class="hljs-comment">// 合法：int隐式转换为C类型作为函数参数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></div></article><div class="post-view__sidebar"><div class="sidebar"><div class="tocbot"><h2>Toc</h2><div class="toc__content"></div></div><h2>Links</h2><div class="sidebar__link"><ul><li><a target="_blank" rel="noopener" href="https://github.com/15hmael">Github</a></li><li><a href="/3556897601@qq.com">Mail</a></li></ul></div><h2>Archives</h2><div class="sidebar__archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/">2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul></div><h2>Categories</h2><div class="sidebar__categories"></div><h2>Tags</h2><div class="sidebar__tags"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bazel/" rel="tag">Bazel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Caffeine/" rel="tag">Caffeine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Clangd/" rel="tag">Clangd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLVM/" rel="tag">LLVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenResty/" rel="tag">OpenResty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/" rel="tag">Redis.多级缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E6%BA%90%E7%A0%81/" rel="tag">Redis源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E9%AB%98%E7%BA%A7/" rel="tag">Redis高级</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reids/" rel="tag">Reids</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zsh/" rel="tag">Zsh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dpdk/" rel="tag">dpdk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hiredis/" rel="tag">hiredis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" rel="tag">分布式缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/" rel="tag">多级缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%91%B8%E9%B1%BC/" rel="tag">摸鱼</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul></div></div></div></div><div class="horizontal-line" style="height: 1px"></div><div class="main__bottom"><div class="pre-next"><a class="pre-button" href="/2025/09/22/%E6%89%8B%E6%90%93STL%E4%B9%8Bpair%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5/">手搓STL之pair类型检查</a><a class="next-button" href="/2025/09/18/C++%E5%8F%B3%E5%80%BC%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/">C++右值和完美转发</a></div></div></div></div><div class="footer"><span>©️2019-2025 Designed By&nbsp;<strong><a target="_blank" rel="noopener" href="https://github.com/random-yang">RandomYang</a></strong> Powered By&nbsp;</span><strong><a target="_blank" rel="noopener" href="https://hexo.io">hexo</a></strong></div><div class="darkmode-mask" id="darkmode-mask"></div><div class="sidebar__button"></div></body></html>